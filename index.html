<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Wire Checker</title>
  <style>
    body { font-family: Arial, sans-serif; text-align: center; margin: 20px; }
    video, canvas { max-width: 90%; margin: 10px; border: 1px solid #ccc; }
    button { margin: 10px; padding: 10px 20px; font-size: 16px; }
    #result { font-size: 24px; margin-top: 20px; }
  </style>
</head>
<body>
  <h2>Wire Sequence Checker</h2>

  <video id="video" autoplay playsinline></video><br>
  <button onclick="captureGolden()">üì∏ Capture Golden</button>
  <button onclick="captureTest()">üì∏ Capture Test</button>
  <button onclick="compare()">‚úÖ Compare</button>

  <h3>Golden</h3>
  <canvas id="goldenCanvas"></canvas>

  <h3>Test</h3>
  <canvas id="testCanvas"></canvas>

  <div id="result"></div>

  <script>
    const video = document.getElementById("video");
    const goldenCanvas = document.getElementById("goldenCanvas");
    const testCanvas = document.getElementById("testCanvas");

    // Use back camera
    navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } })
      .then(stream => { video.srcObject = stream; })
      .catch(err => { alert("Camera error: " + err); });

    function captureGolden() {
      captureToCanvas(goldenCanvas);
    }

    function captureTest() {
      captureToCanvas(testCanvas);
    }

    function captureToCanvas(canvas) {
      const ctx = canvas.getContext("2d");
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    }

    function compare() {
      const roi = { x: 50, y: 50, width: 200, height: 50 }; 
      // ‚ö†Ô∏è Adjust these ROI values so they cover your connector region only

      const goldenColors = getWireColors(goldenCanvas, roi);
      const testColors = getWireColors(testCanvas, roi);

      console.log("Golden:", goldenColors);
      console.log("Test:", testColors);

      if (JSON.stringify(goldenColors) === JSON.stringify(testColors)) {
        document.getElementById("result").textContent = "‚úÖ PASS";
        document.getElementById("result").style.color = "green";
      } else {
        document.getElementById("result").textContent = "‚ùå FAIL";
        document.getElementById("result").style.color = "red";
      }
    }

    function getWireColors(canvas, roi) {
      const ctx = canvas.getContext("2d");
      const { x, y, width, height } = roi;

      const imageData = ctx.getImageData(x, y, width, height);
      const data = imageData.data;

      const numWires = 4; // ‚ö†Ô∏è Adjust this to your connector wire count
      const sliceWidth = Math.floor(width / numWires);

      let colors = [];

      for (let i = 0; i < numWires; i++) {
        let r = 0, g = 0, b = 0, count = 0;
        for (let px = i * sliceWidth; px < (i + 1) * sliceWidth; px++) {
          for (let py = 0; py < height; py++) {
            const idx = ((py * width) + px) * 4;
            r += data[idx];
            g += data[idx + 1];
            b += data[idx + 2];
            count++;
          }
        }
        r = Math.round(r / count);
        g = Math.round(g / count);
        b = Math.round(b / count);

        colors.push(rgbToColorName(r, g, b));
      }

      return colors;
    }

    function rgbToColorName(r, g, b) {
      // Convert to HSV for better color matching
      const hsv = rgbToHsv(r, g, b);
      const [h, s, v] = hsv;

      if (v < 0.2) return "black";
      if (v > 0.8 && s < 0.2) return "white";
      if (s < 0.25 && v < 0.75) return "gray";

      if (h >= 0 && h < 15) return "red";
      if (h >= 15 && h < 45) return "orange";
      if (h >= 45 && h < 70) return "yellow";
      if (h >= 70 && h < 170) return "green";
      if (h >= 170 && h < 255) return "blue";
      if (h >= 255 && h < 285) return "purple";
      if (h >= 285 && h < 330) return "pink";
      if (h >= 330 && h <= 360) return "red";

      return "other";
    }

    function rgbToHsv(r, g, b) {
      r /= 255; g /= 255; b /= 255;
      const max = Math.max(r, g, b), min = Math.min(r, g, b);
      let h, s, v = max;
      const d = max - min;
      s = max === 0 ? 0 : d / max;
      if (max === min) {
        h = 0;
      } else {
        switch (max) {
          case r: h = (g - b) / d + (g < b ? 6 : 0); break;
          case g: h = (b - r) / d + 2; break;
          case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
      }
      return [Math.round(h * 360), s, v];
    }
  </script>
</body>
</html>
